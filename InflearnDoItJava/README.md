# 인프런 Do It 자바 공부

## 기본기 공부하게 된 계기
* 자바를 미션위주로 공부하다가 자바에 대한 기본기 부족을 느껴서 
  시작하게 되었다.

### 컴파일 된 파일 위치
* Out> production>프로젝트 이름으로 된 폴더>class파일
  
### C와 자바의 컴파일 차이
* C언어의 경우에는 컴파일을 하면 OS에 따라 종속적으로 컴파일되어서 만약 리눅스에서 수
  컴파일을 했었는데 윈도우에서 다시 실행하고 싶다면 윈도우에서 다시 컴파일을 해야한다.
* 자바의 경우에는 OS에 종속되지 않고 컴파일 하면 바이트 코드(Example.class)로 
  변환해주고 각 OS에 맞는 자바 가상 머신(JVM)이 한 번 더 해석을 해준다. 처음에는 
  속도가 느렸지만 현재 하드웨어의 발전과 JVM의 업그레이드로 인해서 많이 개선되었다.
  
### 자바를 쓰면 좋은점
* 객체 지향 언어이기 때문에 유지보수가 쉽고 확장성이 좋다.
* 프로그램이 안정적이다.
* 풍부한 기능을 제공하는 오픈 소스이다.

### 16진수를 사용하는 이유
* 2진수 1111의 값은 15이기 때문에 2진수 4자리의 값을 0-15까지의 값(0000-1111)을 가질 수 있다. 그렇기 때문에 64비트를 표현한다고 생각하면 64/4 = 16개로 표현가능하고, 32비트를 표현한다고 생각하면 32/4 =. 개로 표현 가능하기 때문에 보기가 좋다.

#### 2진수, 8진수, 10진수, 16진
* 8진는 000~111까지다.
* 프로그래밍에서 0B로 시작하면 2진수, 0으로 시작하면 8진수, 0X로 시작하면 16진수이다.

### 2진수의 음의 정수를 표현하는 법
-2의 보수를 취하고, 1을 더해주면 된다.

***

### 인코딩, 디코딩
* 인코딩은 각 문자에 따른 특정한 숫자 값(코드 값)을 부여하는 것
* 디코딩은 숫자 값을 원래의 문자로 변환하는 것

### 리터럴
* 프로그램에서 사용하는 모든 숫자, 값, 논리값(ex:10, 3.14, 'A', true)
* 리터럴에 해당 되는 값은 상수 풀(constant pool)에 있다.

### 큰 수에서 작은 수로 값을 대입하게 되면?
* 데이터가 유실하게 되서 원치 않은 결과를 얻을 수 있다.

***

### 삼항 연산자
* 조건식 ? 결과1 : 결과2; ex)int num = (5>3) ? 10: 20; ->num: 10

### 비트 연산자
* 정수에만 사용 가능
* ~ : 비트의 반전(ex:a = ~a;), & : 비트 단위 AND, | : 비트 단위 OR, 
  ^ : 비트 단위 XOR(두 개의 비트가 서로 다른 경우 1반환), 
  \<\< : 왼쪽 쉬프트(2비트 만큼 왼쪽 이동 2의제곱을 곱한다고 생각(2^1, 2^2)), 
  \>\> : 오른쪽 쉬프트(왼쪽 쉬프트와 반대), \>\>\> : 오른쪽 쉬프트(\>\>와 동일하고, 채워지는 비트가 부호와 상관없이 0)

***

### 간단한 조건문
* if(a>b) max = a; 
  else max = b;
  -> max = (a > b) ? a : b;
  
***

### 패키지란?
* 소스의 묶음이라고 할 수 있다.
* 유지보수를 편하기 하기 위해 사용.
* 클래스를 구별해준다.
* 패키지의 계층 구조를 만드는 작업은 소스 코드를 어떠한 계층 구조로 
  관리할지 구성하는 것.

### 함수를 사용하는 이유
* 코드를 효율적으로 구현하기 위해서 사용
* 유지보수에 좋음

### 클래스 생성
* 클래스형 변수이름 = new 생성자;
->Student studentA = new Student();

### 인스턴스
* 힙(heap) 메모리(동적 메모리 공간)에 저장된다.->주소를 저장
* new라는 키워드로 생성된다.
* 하나의 인스턴스가 생성되면 각각의 메모리를 먹는다.

### 용어 정리
* 객체 : 객체 지향 프로그래밍의 대상, 생성된 인스턴스
* 클래스 : 객체를 프로그래밍하기 위해 코드로 만든 상태
* 인스턴스 : 클래스가 메모리에 생성된 상태
* 멤버 변수 : 클래스의 속성, 특성
* 메서드 : 멤버 변수를 이용하여 클래스의 기능을 구현
* 참조 변수 : 메모리에 생성된 인스턴스를 가리키는 변수
* 참조 값 : 생성된 인스턴스의 메모리 주소 값(힙 메모리에 저장)

### 생성자
* 생성자는 인스턴스를 초기화할 때의 명령어 집합
* 생성자의 이름은 그 클래스의 이름과 같음
* 생성자는 메소드가 아님. 상속되지 않으며, 리턴 값은 없음.
* 필요에 의해 생성자 추가 하는 경우 여러 개의 생성자가 하나의 클래스에 있다.(생성자 오버로드)
* 생성자가 없을 때 디폴트 생성자가 제공된다.

### public, private 
* public : 외부 클래스에서 다 가져다 쓸 수 있음.
* private : 같은 클래스내에서 가져다 쓸 수 있음.
* 아무것도 안 쓸 때 : 같은 패키지 내에서 가져다 쓸 수 있음.

***

### this(세 가지 기능)
* 자신의 메모리를 가리킴
  -> heap 메모리의 주소를 가리킴.
* 생성자에서 다른 생성자를 호출
  -> 이 경우엔 this앞에 아무것도 오면 안됌.(생성자가 아직 완성되지 않았기 때문)
* 자신의 주소를 반환 함

***

### static
* 여러 개의 인스턴스가 메모리 값을 공유할 수 있게 해준다.
* 힙 메모리에 저장되는 것이 아니라 메모리를 따로 저장한다.
* 인스턴스가 생성될 때 마다 다른 메모리(힙 메모리)를 가지는 것이 아니라
  프로그램이 메모리에 적재(load)될 때 데이터 영역의 메모리에 생성 된다.-> new를 생성하지 않고 사용 가능
* 다른 말로 클래스 변수라고도 한다.
* 예를 들어 어떤 대학교 학생들에게 ID값을 부여 할 때 serialNum이라는 기준 값을 static변수에 1000을 지정하고
  한 명 늘어 날 때 마다 1을 더해서 고유한 ID값을 부여할 수 있도록 한다.(생성자를 활용)

<img width="397" alt="스크린샷 2020-12-25 오전 6 46 42" src="https://user-images.githubusercontent.com/64648893/103106954-46589980-467d-11eb-8341-a091b2fe35cb.png">

### static 응용 : singleton 패턴
* 객체가 여러 개이면 안될 때 singleton 패턴 사용

***

### 배열
* 동일한 자료형의 변수를 한꺼번에 순차적으로 관리할 수 있다.
* 자료형[] arr = new 자료형[개수]; -> 이런식으로 선언
* arr.length는 배열 중간에 비어있는 값은 고려하지 않고 처음에 선언한
  총 길이를 표현한다.
  
<img width="373" alt="스크린샷 2020-12-25 오전 8 49 59" src="https://user-images.githubusercontent.com/64648893/103111237-385f4480-468e-11eb-80fa-9a0ee60a705d.png">

### 객체 배열
* 참조 자료형을 선언하는 객체 배열
* 배열만 생성 한 경우 요소는 null로 초기화 됌.
* 각 요소를 new를 활용하여 생성하고 저장해야 함.
* 객체 배열을 일반 배열과 같이 복사한다면 주소가 복사되는 것이라서
  복사한 곳과 복사된 곳이 같이 값이 변경된다.(얕은 복사)
* 얕은 복사 문제를 해결하려면 깊은 복사를 하면 됌.

***

### 상속
* 클래스에 extends 클래스명을 붙이면 상속된다.
* 하위클래스가 생성될 때 항상 상위 클래스가 먼저 생성된다.
* 하위클래스가 상위클래스의 타입을 내포하고 있기 때문에 상위클래스로의
  형변환이 묵시적으로 이루어질 수 있다.(업캐스팅)
  ex) Customer vc = new VIPCustomer();
  ->VIPCustomer() 생성자의 호출로 인스턴스는 모두 생성되었지만
  타입이 Customer 이므로 접근 할 수 있는 변수나 메서드는 Customer의 변수와 메서드이다.

### protected
* 상속 관계에서는 public과 비슷하다.
* 가시성 : public > protected > default > private

<img width="353" alt="스크린샷 2020-12-25 오전 11 34 42" src="https://user-images.githubusercontent.com/64648893/103115251-38b70a00-46a5-11eb-8bd1-63914d3fedaa.png">

### 메서드 오버라이딩
* 오버로드는 여러 개를 동시에 쓰는 거라면 오버 라이딩은 덮어쓰기라고 보면 된다.

<img width="366" alt="스크린샷 2020-12-25 오후 12 57 37" src="https://user-images.githubusercontent.com/64648893/103118159-fb587980-46b0-11eb-8ef4-4f26f7050cda.png">

### 다형성
* 상속이 있고, 하위 클래스가 상위 클래스의 타입으로 대입이 된다. 하위 클래스에서 상위 클래서의 매서드를
  재정의 할 수 있다. 그리고 하위 클래스가 상위 클래스의 타입으로 대입된 경우에 똑같은 메서드가 호출 되면
  타입께 아닌 인스턴스께 불린다. 이런것이 다형성을 구현할 수 있는 기반이 된다.
* 하나의 코드가 여러가지 자료형으로 구현되어 실행되는 것으로, 정보은닉, 상속과 더불어 객체지향 프로그래밍의
  가장 큰 특징 중 하나이며, 객체지향 프로그래밍의 유연성, 재활용성, 유지보수성에 기본이 되는 특징이다.

<img width="344" alt="스크린샷 2020-12-25 오후 3 42 12" src="https://user-images.githubusercontent.com/64648893/103123465-cc99cd80-46c7-11eb-8eb2-40ca6dcf7485.png">

***

### 추상 클래스
* 추상(abstract)메서드를 가지고 있으면 그 클래스는 추상 클래스가 된다.
* 추상 클래스는 상속하기 위해 만드는 클래스이다.
* 인스턴스화 될 수 없다.
* 추상 클래스를 상속 받으면 추상 클래스에 있는 추상 메소드를 하위 클래스가 구현해야 할
  책임이 있다.
  
### 템플릿 메서드
* 추상 메서드나 구현된 메서드를 활용하여 전체 기능의 흐름(시나리오)을 정의하는 메서드
* final로 선언하면 하위 클래스에서 재정의 할 수 없다.
* 일련의 과정을 시나리오로 만들어 놓은 메서드라고 보면 됌.
* 시나리오가 바뀌면 안되기 때문에 final로 선언함.
* 프레임워크에서 많이 사용되는 패턴이다.

<img width="347" alt="스크린샷 2020-12-25 오후 9 26 38" src="https://user-images.githubusercontent.com/64648893/103134939-eb17bd00-46f7-11eb-83c5-417a261d24d2.png">

### final
* final 메서드는 하위 클래스에서 재정의(overriding)할 수 없다.
* final 클래스는 더 이상 상속되지 않는다.

### 인터페이스
* 모든 메서드가 추상 메서드로 이루어진 클래스
* 형식적인 선언만 있고 구현은 없다.
* 인터페이스에 선언된 모든 메서드는 public abstract로 추상 메서드이고, 모든 변수는 public static final로 상수이다.
* interface, implement는 타입 상속, class, extends는 구현 상속이다.
* 프로그래밍 설계하는데 사용된다.
* 클라이언트 코드에서는 인터페이스 명세에 기반하여 가져다 쓴다.
* default메서드가 중복되는 경우 재정의 해주어야 한다.

<img width="345" alt="스크린샷 2020-12-26 오전 6 49 57" src="https://user-images.githubusercontent.com/64648893/103142461-9c454400-4746-11eb-98ee-444c29b406ca.png">

<img width="339" alt="스크린샷 2020-12-26 오전 7 13 59" src="https://user-images.githubusercontent.com/64648893/103142652-11fedf00-474a-11eb-81c5-af44fa6a4c3f.png">

<img width="326" alt="스크린샷 2020-12-26 오전 7 50 02" src="https://user-images.githubusercontent.com/64648893/103142888-08c44100-474f-11eb-9406-a53f986b4ac2.png">
